# PRD: Интеграция Серверного Мода (DayZ-RSTRT)

## 1. Обзор
Этот документ определяет архитектуру кастомного серверного мода DayZ (**Enforce Script**), предназначенного для расширения возможностей телеметрии и управления менеджера **DayZ-RSTRT**.
Мод выступает в роли моста между игровым движком и Electron-приложением, преодолевая ограничения стандартного RCON.

## 2. Цели
1.  **Высокоточная телеметрия**: Получение данных, недоступных через RCON (FPS сервера/TickRate, точные позиции игроков, здоровье).
2.  **Продвинутое управление**: Выполнение сложной логики через кастомные команды.
3.  **Архитектура Моста**: Создание надежного канала связи через HTTP REST API.

## 3. Архитектура и Коммуникация

### 3.1 Паттерн Интеграции: HTTP/RestApi (Реализовано)
Мы используем модуль **RestApi** движка DayZ для отправки телеметрии напрямую в Менеджер.

*   **Триггер**: Таймер (каждые 5 секунд).
*   **Отправитель**: Мод использует `GetRestApi()` для отправки HTTP POST запросов.
*   **Получатель**: Менеджер (Electron) хостит легковесный Express.js сервер на порту 3000.
*   **Пейлоад**: JSON с FPS сервера, количеством игроков и деталями игроков.
*   **Конфигурация**: Динамический `config.json` в `$profile:DayZ-RSTRT/` позволяет менять Целевой IP/Порт без перекомпиляции.

### 3.2 Структура Файлов
```text
server-mod/
├── config.cpp              # Определение CfgPatches
└── Scripts/
    └── 5_Mission/
        └── missionServer.c # Хуки OnUpdate/Events, загрузка конфига и логика RestApi
```

## 4. Технические Спецификации (Enforce Script)

### 4.1 Конфигурация (config.json)
Мод автоматически создает/читает `$profile:DayZ-RSTRT/config.json` при запуске.
```json
{
    "Endpoint": "http://127.0.0.1:3000/api/telemetry"
}
```

### 4.2 Реализация RestApi
Мы используем `RestContext` для управления передачей данных и кастомный коллбэк для обработки ошибок.

```csharp
modded class MissionServer {
    private RestContext m_RstrtApi;
    private ref RSTRT_RestCallback m_RstrtCallback;
    
    override void OnInit() {
        super.OnInit();
        // 1. Загрузка конфига
        LoadConfig(); 
        
        // 2. Инициализация соединения
        m_RstrtApi = GetRestApi().GetRestContext(m_RstrtConfig.Endpoint);
        m_RstrtCallback = new RSTRT_RestCallback(); // Кастомный обработчик ошибок
        
        // 3. Запуск цикла телеметрии
        GetGame().GetCallQueue(CALL_CATEGORY_SYSTEM).CallLater(Rstrt_SendTelemetry, 5000, true);
    }

    void Rstrt_SendTelemetry() {
        if (!m_RstrtApi) return;
        
        // Сбор данных (Оптимизировано: string.Format во избежание аллокаций)
        float fps = m_Rstrt_CurrentFps; 
        string json = string.Format("{\"fps\":%1...", fps);
        
        // ... Цикл по игрокам с оптимизированным форматированием ...

        m_RstrtApi.POST(m_RstrtCallback, "", json);
    }
}
```

### 4.3 Сторона Менеджера (Electron)
*   **Компонент**: `TelemetryServer.ts` (Node.js/Express).
*   **Логика**:
    1.  Получает JSON.
    2.  Извлекает `id` (SteamID64).
    3.  Вычисляет `guid = MD5(id)`.
    4.  Обновляет Zustand Store.
    5.  Store объединяет это с данными RCON (сопоставление по GUID).

## 5. Статус Реализации
*   **RestApi**: ✅ Реализовано.
*   **Загрузчик Конфига**: ✅ Реализовано (JsonFileLoader).
*   **SteamID -> GUID**: ✅ Реализовано (на стороне Electron).
*   **Обнаружение Зависаний**: ✅ Реализовано (Логика приложения).
*   **Оптимизация**: ✅ Реализовано (Переиспользование массивов, эффективная сборка строк).

## 6. Оценка Надежности и Риски
*   **Доступность RestApi**: **Высокая**. Работает надежно на локальных и удаленных серверах (модель push).
*   **Производительность**: **Высокая**. Минимальное влияние на FPS сервера благодаря оптимизации кода.
